


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>spack Package &mdash; Spack 1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'',
        VERSION:'1.0',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="Spack 1.0 documentation" href="index.html"/>
        <link rel="next" title="cmd Package" href="spack.cmd.html"/>
        <link rel="prev" title="Developer Guide" href="developer_guide.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="icon icon-home"> Spack</a>
        <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="features.html">Feature Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="features.html#simple-package-installation">Simple package installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#custom-versions-configurations">Custom versions &amp; configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#customize-dependencies">Customize dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#non-destructive-installs">Non-destructive installs</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#packages-can-peacefully-coexist">Packages can peacefully coexist</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#creating-packages-is-easy">Creating packages is easy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#download">Download</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting_started.html#install">Install</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="basic_usage.html">Basic usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#getting-help">Getting Help</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#listing-available-packages">Listing available packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#seeing-installed-packages">Seeing installed packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#installing-and-uninstalling">Installing and uninstalling</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#specs-dependencies">Specs &amp; Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="basic_usage.html#virtual-dependencies">Virtual dependencies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="packaging_guide.html">Packaging Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#package-files">Package Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#creating-packages">Creating Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#virtual-dependencies">Virtual dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#abstract-concrete-specs">Abstract &amp; concrete specs</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#install-environment">Install environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#implementing-the-install-method">Implementing the <tt class="docutils literal"><span class="pre">install</span></tt> method</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#prefix-objects">Prefix objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#spec-objects">Spec objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#shell-command-wrappers">Shell command wrappers</a></li>
<li class="toctree-l2"><a class="reference internal" href="packaging_guide.html#the-package-build-process">The package build process</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="site_configuration.html">Site-specific configuration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="site_configuration.html#temporary-space">Temporary space</a></li>
<li class="toctree-l2"><a class="reference internal" href="site_configuration.html#concretization-policies">Concretization policies</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#directory-structure">Directory Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#code-structure">Code Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#spec-objects">Spec objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#package-objects">Package objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#stage-objects">Stage objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#writing-commands">Writing commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#id3">Unit tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#unit-testing">Unit testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="developer_guide.html#developer-commands">Developer commands</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">API Docs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">spack</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.architecture"><tt class="docutils literal"><span class="pre">architecture</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.colify"><tt class="docutils literal"><span class="pre">colify</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.color"><tt class="docutils literal"><span class="pre">color</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.compilation"><tt class="docutils literal"><span class="pre">compilation</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.concretize"><tt class="docutils literal"><span class="pre">concretize</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.directory_layout"><tt class="docutils literal"><span class="pre">directory_layout</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.error"><tt class="docutils literal"><span class="pre">error</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.globals"><tt class="docutils literal"><span class="pre">globals</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.multimethod"><tt class="docutils literal"><span class="pre">multimethod</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.package"><tt class="docutils literal"><span class="pre">package</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.parse"><tt class="docutils literal"><span class="pre">parse</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.relations"><tt class="docutils literal"><span class="pre">relations</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.spec"><tt class="docutils literal"><span class="pre">spec</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.stage"><tt class="docutils literal"><span class="pre">stage</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.tty"><tt class="docutils literal"><span class="pre">tty</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.url"><tt class="docutils literal"><span class="pre">url</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.validate"><tt class="docutils literal"><span class="pre">validate</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-spack.version"><tt class="docutils literal"><span class="pre">version</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="index.html">Spack</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="index.html">Docs</a> &raquo;</li>
  <li><a href="">spack Package</a></li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="_sources/spack.txt" rel="nofollow"> View page source</a>
      
    </li>
</ul>
<hr/>

          
  <div class="section" id="spack-package">
<h1>spack Package<a class="headerlink" href="#spack-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">spack</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-spack.__init__"></span></div>
<div class="section" id="module-spack.architecture">
<span id="architecture-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">architecture</span></tt> Module<a class="headerlink" href="#module-spack.architecture" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.architecture.InvalidSysTypeError">
<em class="property">exception </em><tt class="descclassname">spack.architecture.</tt><tt class="descname">InvalidSysTypeError</tt><big>(</big><em>sys_type</em><big>)</big><a class="headerlink" href="#spack.architecture.InvalidSysTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
</dd></dl>

<dl class="exception">
<dt id="spack.architecture.NoSysTypeError">
<em class="property">exception </em><tt class="descclassname">spack.architecture.</tt><tt class="descname">NoSysTypeError</tt><a class="headerlink" href="#spack.architecture.NoSysTypeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.get_mac_sys_type">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">get_mac_sys_type</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.architecture.get_mac_sys_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Mac OS SYS_TYPE or None if this isn&#8217;t a mac.</p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.get_sys_type_from_environment">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">get_sys_type_from_environment</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.architecture.get_sys_type_from_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Return $SYS_TYPE or None if it&#8217;s not defined.</p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.get_sys_type_from_spack_globals">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">get_sys_type_from_spack_globals</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.architecture.get_sys_type_from_spack_globals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the SYS_TYPE from spack globals, or None if it isn&#8217;t set.</p>
</dd></dl>

<dl class="function">
<dt id="spack.architecture.sys_type">
<tt class="descclassname">spack.architecture.</tt><tt class="descname">sys_type</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.architecture.sys_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a SysType for the current machine.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.colify">
<span id="colify-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">colify</span></tt> Module<a class="headerlink" href="#module-spack.colify" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="spack.colify.ColumnConfig">
<em class="property">class </em><tt class="descclassname">spack.colify.</tt><tt class="descname">ColumnConfig</tt><big>(</big><em>cols</em><big>)</big><a class="headerlink" href="#spack.colify.ColumnConfig" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.colify.colify">
<tt class="descclassname">spack.colify.</tt><tt class="descname">colify</tt><big>(</big><em>elts</em>, <em>**options</em><big>)</big><a class="headerlink" href="#spack.colify.colify" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.colify.config_uniform_cols">
<tt class="descclassname">spack.colify.</tt><tt class="descname">config_uniform_cols</tt><big>(</big><em>elts</em>, <em>console_cols</em>, <em>padding</em><big>)</big><a class="headerlink" href="#spack.colify.config_uniform_cols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.colify.config_variable_cols">
<tt class="descclassname">spack.colify.</tt><tt class="descname">config_variable_cols</tt><big>(</big><em>elts</em>, <em>console_cols</em>, <em>padding</em><big>)</big><a class="headerlink" href="#spack.colify.config_variable_cols" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.colify.get_terminal_size">
<tt class="descclassname">spack.colify.</tt><tt class="descname">get_terminal_size</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.colify.get_terminal_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimensions of the console.</p>
</dd></dl>

<dl class="function">
<dt id="spack.colify.isatty">
<tt class="descclassname">spack.colify.</tt><tt class="descname">isatty</tt><big>(</big><em>ostream</em><big>)</big><a class="headerlink" href="#spack.colify.isatty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-spack.color">
<span id="color-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">color</span></tt> Module<a class="headerlink" href="#module-spack.color" title="Permalink to this headline">¶</a></h2>
<p>This file implements an expression syntax, similar to printf, for adding
ANSI colors to text.</p>
<p>See colorize(), cwrite(), and cprint() for routines that can generate
colored output.</p>
<p>colorize will take a string and replace all color expressions with
ANSI control codes.  If the isatty keyword arg is set to False, then
the color expressions will be converted to null strings, and the
returned string will have no color.</p>
<p>cwrite and cprint are equivalent to write() and print() calls in
python, but they colorize their output.  If the stream argument is
not supplied, they write to sys.stdout.</p>
<p>Here are some example color expressions:</p>
<blockquote>
<div>&#64;r         Turn on red coloring
&#64;R         Turn on bright red coloring
&#64;*b        Turn on bold, blue text
&#64;_B        Turn on bright blue text with an underline
&#64;.         Revert to plain formatting
&#64;*g{green} Print out &#8216;green&#8217; in bold, green text, then reset to plain.
&#64;*ggreen&#64;. Print out &#8216;green&#8217; in bold, green text, then reset to plain.</div></blockquote>
<p>The syntax consists of:</p>
<blockquote>
<div>color-expr    = &#8216;&#64;&#8217; [style] color-code &#8216;{&#8216; text &#8216;}&#8217; | &#8216;&#64;.&#8217; | &#8216;&#64;&#64;&#8217;
style         = &#8216;*&#8217; | &#8216;_&#8217;
color-code    = [krgybmcwKRGYBMCW]
text          = .*</div></blockquote>
<p>&#8216;&#64;&#8217; indicates the start of a color expression.  It can be followed
by an optional * or _ that indicates whether the font should be bold or
underlined.  If * or _ is not provided, the text will be plain.  Then
an optional color code is supplied.  This can be [krgybmcw] or [KRGYBMCW],
where the letters map to  black(k), red(r), green(g), yellow(y), blue(b),
magenta(m), cyan(c), and white(w).  Lowercase letters denote normal ANSI
colors and capital letters denote bright ANSI colors.</p>
<p>Finally, the color expression can be followed by text enclosed in {}.  If
braces are present, only the text in braces is colored.  If the braces are
NOT present, then just the control codes to enable the color will be output.
The console can be reset later to plain text with &#8216;&#64;.&#8217;.</p>
<p>To output an &#64;, use &#8216;&#64;&#64;&#8217;.  To output a } inside braces, use &#8216;}}&#8217;.</p>
<dl class="exception">
<dt id="spack.color.ColorParseError">
<em class="property">exception </em><tt class="descclassname">spack.color.</tt><tt class="descname">ColorParseError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.color.ColorParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when a color format fails to parse.</p>
</dd></dl>

<dl class="class">
<dt id="spack.color.ColorStream">
<em class="property">class </em><tt class="descclassname">spack.color.</tt><tt class="descname">ColorStream</tt><big>(</big><em>stream</em>, <em>color=None</em><big>)</big><a class="headerlink" href="#spack.color.ColorStream" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="spack.color.ColorStream.write">
<tt class="descname">write</tt><big>(</big><em>string</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.color.ColorStream.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.color.ColorStream.writelines">
<tt class="descname">writelines</tt><big>(</big><em>sequence</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.color.ColorStream.writelines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.color.cescape">
<tt class="descclassname">spack.color.</tt><tt class="descname">cescape</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.color.cescape" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all &#64; with &#64;&#64; in the string provided.</p>
</dd></dl>

<dl class="function">
<dt id="spack.color.colorize">
<tt class="descclassname">spack.color.</tt><tt class="descname">colorize</tt><big>(</big><em>string</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.color.colorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a string and replace all color expressions with ANSI control
codes.  Return the resulting string.
If color=False is supplied, output will be plain text without
control codes, for output to non-console devices.</p>
</dd></dl>

<dl class="function">
<dt id="spack.color.cprint">
<tt class="descclassname">spack.color.</tt><tt class="descname">cprint</tt><big>(</big><em>string</em>, <em>stream=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x1064de150&gt;</em>, <em>color=None</em><big>)</big><a class="headerlink" href="#spack.color.cprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as cwrite, but writes a trailing newline to the stream.</p>
</dd></dl>

<dl class="function">
<dt id="spack.color.cwrite">
<tt class="descclassname">spack.color.</tt><tt class="descname">cwrite</tt><big>(</big><em>string</em>, <em>stream=&lt;open file '&lt;stdout&gt;'</em>, <em>mode 'w' at 0x1064de150&gt;</em>, <em>color=None</em><big>)</big><a class="headerlink" href="#spack.color.cwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace all color expressions in string with ANSI control
codes and write the result to the stream.  If color is
False, this will write plain text with o color.  If True,
then it will always write colored output.  If not supplied,
then it will be set based on stream.isatty().</p>
</dd></dl>

<dl class="class">
<dt id="spack.color.match_to_ansi">
<em class="property">class </em><tt class="descclassname">spack.color.</tt><tt class="descname">match_to_ansi</tt><big>(</big><em>color=True</em><big>)</big><a class="headerlink" href="#spack.color.match_to_ansi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="spack.color.match_to_ansi.escape">
<tt class="descname">escape</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#spack.color.match_to_ansi.escape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a TTY escape sequence for a color</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack.compilation">
<span id="compilation-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">compilation</span></tt> Module<a class="headerlink" href="#module-spack.compilation" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">compilation</span></tt> module contains utility functions used by the compiler
wrapper script.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Think about moving this into the script to increase compilation
speed.</p>
</div>
<dl class="function">
<dt id="spack.compilation.get_env_flag">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">get_env_flag</tt><big>(</big><em>name</em>, <em>required=False</em><big>)</big><a class="headerlink" href="#spack.compilation.get_env_flag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.compilation.get_env_var">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">get_env_var</tt><big>(</big><em>name</em>, <em>required=True</em><big>)</big><a class="headerlink" href="#spack.compilation.get_env_var" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.compilation.get_path">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">get_path</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#spack.compilation.get_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.compilation.parse_rpaths">
<tt class="descclassname">spack.compilation.</tt><tt class="descname">parse_rpaths</tt><big>(</big><em>arguments</em><big>)</big><a class="headerlink" href="#spack.compilation.parse_rpaths" title="Permalink to this definition">¶</a></dt>
<dd><p>argparse, for all its features, cannot understand most compilers&#8217;
rpath arguments.  This handles &#8216;-Wl,&#8217;, &#8216;-Xlinker&#8217;, and &#8216;-R&#8217;</p>
</dd></dl>

</div>
<div class="section" id="module-spack.concretize">
<span id="concretize-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">concretize</span></tt> Module<a class="headerlink" href="#module-spack.concretize" title="Permalink to this headline">¶</a></h2>
<p>Functions here are used to take abstract specs and make them concrete.
For example, if a spec asks for a version between 1.8 and 1.9, these
functions might take will take the most recent 1.9 version of the
package available.  Or, if the user didn&#8217;t specify a compiler for a
spec, then this will assign a compiler to the spec based on defaults
or user preferences.</p>
<dl class="docutils">
<dt>TODO: make this customizable and allow users to configure</dt>
<dd>concretization  policies.</dd>
</dl>
<dl class="class">
<dt id="spack.concretize.DefaultConcretizer">
<em class="property">class </em><tt class="descclassname">spack.concretize.</tt><tt class="descname">DefaultConcretizer</tt><a class="headerlink" href="#spack.concretize.DefaultConcretizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This class doesn&#8217;t have any state, it just provides some methods for
concretization.  You can subclass it to override just some of the
default concretization strategies, or you can override all of them.</p>
<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.choose_provider">
<tt class="descname">choose_provider</tt><big>(</big><em>spec</em>, <em>providers</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.choose_provider" title="Permalink to this definition">¶</a></dt>
<dd><p>This is invoked for virtual specs.  Given a spec with a virtual name,
say &#8220;mpi&#8221;, and a list of specs of possible providers of that spec,
select a provider and return it.</p>
</dd></dl>

<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.concretize_architecture">
<tt class="descname">concretize_architecture</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.concretize_architecture" title="Permalink to this definition">¶</a></dt>
<dd><p>If the spec already had an architecture, return.  Otherwise if
the root of the DAG has an architecture, then use that.
Otherwise take the system&#8217;s default architecture.</p>
<p>Intuition: Architectures won&#8217;t be set a lot, and generally you
want the host system&#8217;s architecture.  When architectures are
mised in a spec, it is likely because the tool requries a
cross-compiled component, e.g. for tools that run on BlueGene
or Cray machines.  These constraints will likely come directly
from packages, so require the user to be explicit if they want
to mess with the architecture, and revert to the default when
they&#8217;re not explicit.</p>
</dd></dl>

<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.concretize_compiler">
<tt class="descname">concretize_compiler</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.concretize_compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently just sets the compiler to gcc or throws an exception
if the compiler is set to something else.</p>
<p>TODO: implement below description.</p>
<p>If the spec already has a compiler, we&#8217;re done.  If not, then
take the compiler used for the nearest ancestor with a concrete
compiler, or use the system default if there is no ancestor
with a compiler.</p>
<p>Intuition: Use the system default if no package that depends on
this one has a strict compiler requirement.  Otherwise, try to
build with the compiler that will be used by libraries that
link to this one, to maximize compatibility.</p>
</dd></dl>

<dl class="method">
<dt id="spack.concretize.DefaultConcretizer.concretize_version">
<tt class="descname">concretize_version</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.concretize.DefaultConcretizer.concretize_version" title="Permalink to this definition">¶</a></dt>
<dd><p>If the spec is already concrete, return.  Otherwise take
the most recent available version, and default to the package&#8217;s
version if there are no avaialble versions.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack.directory_layout">
<span id="directory-layout-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">directory_layout</span></tt> Module<a class="headerlink" href="#module-spack.directory_layout" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="spack.directory_layout.DirectoryLayout">
<em class="property">class </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">DirectoryLayout</tt><big>(</big><em>root</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A directory layout is used to associate unique paths with specs.
Different installations are going to want differnet layouts for their
install, and they can use this to customize the nesting structure of
spack installs.</p>
<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.all_specs">
<tt class="descname">all_specs</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.all_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>To be implemented by subclasses to traverse all specs for which there is
a directory within the root.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.make_path_for_spec">
<tt class="descname">make_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.make_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the installation directory for a spec.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.path_for_spec">
<tt class="descname">path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an absolute path from the root to a directory for the spec.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.relative_path_for_spec">
<tt class="descname">relative_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.relative_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Implemented by subclasses to return a relative path from the install
root to a unique location for the provided spec.</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.DirectoryLayout.remove_path_for_spec">
<tt class="descname">remove_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayout.remove_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a prefix and any empty parent directories from the root.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.DirectoryLayoutError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">DirectoryLayoutError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.directory_layout.DirectoryLayoutError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Superclass for directory layout errors.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.InconsistentInstallDirectoryError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">InconsistentInstallDirectoryError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.directory_layout.InconsistentInstallDirectoryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayoutError" title="spack.directory_layout.DirectoryLayoutError"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayoutError</span></tt></a></p>
<p>Raised when a package seems to be installed to the wrong place.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.InstallDirectoryAlreadyExistsError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">InstallDirectoryAlreadyExistsError</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.directory_layout.InstallDirectoryAlreadyExistsError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayoutError" title="spack.directory_layout.DirectoryLayoutError"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayoutError</span></tt></a></p>
<p>Raised when make_path_for_sec is called unnecessarily.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.directory_layout.SpecHashCollisionError">
<em class="property">exception </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">SpecHashCollisionError</tt><big>(</big><em>installed_spec</em>, <em>new_spec</em>, <em>prefix_size</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashCollisionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayoutError" title="spack.directory_layout.DirectoryLayoutError"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayoutError</span></tt></a></p>
<p>Raised when there is a hash collision in an SpecHashDirectoryLayout.</p>
</dd></dl>

<dl class="class">
<dt id="spack.directory_layout.SpecHashDirectoryLayout">
<em class="property">class </em><tt class="descclassname">spack.directory_layout.</tt><tt class="descname">SpecHashDirectoryLayout</tt><big>(</big><em>root</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.directory_layout.DirectoryLayout" title="spack.directory_layout.DirectoryLayout"><tt class="xref py py-class docutils literal"><span class="pre">spack.directory_layout.DirectoryLayout</span></tt></a></p>
<dl class="docutils">
<dt>Lays out installation directories like this::</dt>
<dd><dl class="first last docutils">
<dt>&lt;install_root&gt;/</dt>
<dd><dl class="first last docutils">
<dt>&lt;architecture&gt;/</dt>
<dd><dl class="first last docutils">
<dt>&lt;compiler&gt;/</dt>
<dd><a class="reference external" href="mailto:name&#37;&#52;&#48;version+variant">name<span>&#64;</span>version+variant</a>-&lt;dependency_hash&gt;</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>Where dependency_hash is a SHA-1 hash prefix for the full package spec.
This accounts for dependencies.</p>
<p>If there is ever a hash collision, you won&#8217;t be able to install a new
package unless you use a larger prefix.  However, the full spec is stored
in a file called .spec in each directory, so you can migrate an entire
install directory to a new hash size pretty easily.</p>
<p>TODO: make a tool to migrate install directories to different hash sizes.</p>
<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.all_specs">
<tt class="descname">all_specs</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.all_specs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.make_path_for_spec">
<tt class="descname">make_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.make_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.read_spec">
<tt class="descname">read_spec</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.read_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the contents of a file and parse them as a spec</p>
</dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.relative_path_for_spec">
<tt class="descname">relative_path_for_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.relative_path_for_spec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.directory_layout.SpecHashDirectoryLayout.write_spec">
<tt class="descname">write_spec</tt><big>(</big><em>spec</em>, <em>path</em><big>)</big><a class="headerlink" href="#spack.directory_layout.SpecHashDirectoryLayout.write_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a spec out to a file.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.directory_layout.traverse_dirs_at_depth">
<tt class="descclassname">spack.directory_layout.</tt><tt class="descname">traverse_dirs_at_depth</tt><big>(</big><em>root</em>, <em>depth</em>, <em>path_tuple=()</em>, <em>curdepth=0</em><big>)</big><a class="headerlink" href="#spack.directory_layout.traverse_dirs_at_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>For each directory at &lt;depth&gt; within &lt;root&gt;, return a tuple representing
the ancestors of that directory.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.error">
<span id="error-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">error</span></tt> Module<a class="headerlink" href="#module-spack.error" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.error.NoNetworkConnectionError">
<em class="property">exception </em><tt class="descclassname">spack.error.</tt><tt class="descname">NoNetworkConnectionError</tt><big>(</big><em>message</em>, <em>url</em><big>)</big><a class="headerlink" href="#spack.error.NoNetworkConnectionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when an operation needs an internet connection.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.error.SpackError">
<em class="property">exception </em><tt class="descclassname">spack.error.</tt><tt class="descname">SpackError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.error.SpackError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
<p>This is the superclass for all Spack errors.
Subclasses can be found in the modules they have to do with.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.error.UnsupportedPlatformError">
<em class="property">exception </em><tt class="descclassname">spack.error.</tt><tt class="descname">UnsupportedPlatformError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.error.UnsupportedPlatformError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised by packages when a platform is not supported</p>
</dd></dl>

</div>
<div class="section" id="module-spack.globals">
<span id="globals-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">globals</span></tt> Module<a class="headerlink" href="#module-spack.globals" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-spack.multimethod">
<span id="multimethod-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">multimethod</span></tt> Module<a class="headerlink" href="#module-spack.multimethod" title="Permalink to this headline">¶</a></h2>
<p>This module contains utilities for using multi-methods in
spack. You can think of multi-methods like overloaded methods &#8211;
they&#8217;re methods with the same name, and we need to select a version
of the method based on some criteria.  e.g., for overloaded
methods, you would select a version of the method to call based on
the types of its arguments.</p>
<p>In spack, multi-methods are used to ease the life of package
authors.  They allow methods like install() (or other methods
called by install()) to declare multiple versions to be called when
the package is instantiated with different specs.  e.g., if the
package is built with OpenMPI on x86_64,, you might want to call a
different install method than if it was built for mpich2 on
BlueGene/Q.  Likewise, you might want to do a different type of
install for different versions of the package.</p>
<p>Multi-methods provide a simple decorator-based syntax for this that
avoids overly complicated rat nests of if statements.  Obviously,
depending on the scenario, regular old conditionals might be clearer,
so package authors should use their judgement.</p>
<dl class="exception">
<dt id="spack.multimethod.MultiMethodError">
<em class="property">exception </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">MultiMethodError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.multimethod.MultiMethodError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Superclass for multimethod dispatch errors</p>
</dd></dl>

<dl class="exception">
<dt id="spack.multimethod.NoSuchMethodError">
<em class="property">exception </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">NoSuchMethodError</tt><big>(</big><em>cls</em>, <em>method_name</em>, <em>spec</em>, <em>possible_specs</em><big>)</big><a class="headerlink" href="#spack.multimethod.NoSuchMethodError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when we can&#8217;t find a version of a multi-method.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.multimethod.SpecMultiMethod">
<tt class="descclassname">spack.multimethod.</tt><tt class="descname">SpecMultiMethod</tt><a class="headerlink" href="#spack.multimethod.SpecMultiMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>This implements a multi-method for Spack specs.  Packages are
instantiated with a particular spec, and you may want to
execute different versions of methods based on what the spec
looks like.  For example, you might want to call a different
version of install() for one platform than you call on another.</p>
<p>The SpecMultiMethod class implements a callable object that
handles method dispatch.  When it is called, it looks through
registered methods and their associated specs, and it tries
to find one that matches the package&#8217;s spec.  If it finds one
(and only one), it will call that method.</p>
<p>The package author is responsible for ensuring that only one
condition on multi-methods ever evaluates to true.  If
multiple methods evaluate to true, this will raise an
exception.</p>
<p>This is intended for use with decorators (see below).  The
decorator (see docs below) creates SpecMultiMethods and
registers method versions with them.</p>
<dl class="docutils">
<dt>To register a method, you can do something like this:</dt>
<dd>mm = SpecMultiMethod()
mm.register(&#8220;^chaos_5_x86_64_ib&#8221;, some_method)</dd>
</dl>
<p>The object registered needs to be a Spec or some string that
will parse to be a valid spec.</p>
<p>When the mm is actually called, it selects a version of the
method to call based on the sys_type of the object it is
called on.</p>
<p>See the docs for decorators below for more details.</p>
</dd></dl>

<dl class="class">
<dt id="spack.multimethod.when">
<em class="property">class </em><tt class="descclassname">spack.multimethod.</tt><tt class="descname">when</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.multimethod.when" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-spack.package">
<span id="package-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">package</span></tt> Module<a class="headerlink" href="#module-spack.package" title="Permalink to this headline">¶</a></h2>
<p>This is where most of the action happens in Spack.
See the Package docs for detailed instructions on how the class works
and on how to write your own packages.</p>
<p>The spack package structure is based strongly on Homebrew
(<a class="reference external" href="http://wiki.github.com/mxcl/homebrew/">http://wiki.github.com/mxcl/homebrew/</a>), mainly because
Homebrew makes it very easy to create packages.  For a complete
rundown on spack and how it differs from homebrew, look at the
README.</p>
<dl class="exception">
<dt id="spack.package.InvalidPackageDependencyError">
<em class="property">exception </em><tt class="descclassname">spack.package.</tt><tt class="descname">InvalidPackageDependencyError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.package.InvalidPackageDependencyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when package specification is inconsistent with requirements of
its dependencies.</p>
</dd></dl>

<dl class="class">
<dt id="spack.package.MakeExecutable">
<em class="property">class </em><tt class="descclassname">spack.package.</tt><tt class="descname">MakeExecutable</tt><big>(</big><em>name</em>, <em>parallel</em><big>)</big><a class="headerlink" href="#spack.package.MakeExecutable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="spack.util.html#spack.util.executable.Executable" title="spack.util.executable.Executable"><tt class="xref py py-class docutils literal"><span class="pre">spack.util.executable.Executable</span></tt></a></p>
<p>Special Executable for make so the user can specify parallel or
not on a per-invocation basis.  Using &#8216;parallel&#8217; as a kwarg will
override whatever the package&#8217;s global setting is, so you can
either default to true or false and override particular calls.</p>
<p>Note that if the SPACK_NO_PARALLEL_MAKE env var is set it overrides
everything.</p>
</dd></dl>

<dl class="class">
<dt id="spack.package.Package">
<em class="property">class </em><tt class="descclassname">spack.package.</tt><tt class="descname">Package</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.package.Package" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>This is the superclass for all spack packages.</p>
<p><strong>*The Package class*</strong></p>
<p>Package is where the bulk of the work of installing packages is done.</p>
<p>A package defines how to fetch, verfiy (via, e.g., md5), build, and
install a piece of software.  A Package also defines what other
packages it depends on, so that dependencies can be installed along
with the package itself.  Packages are written in pure python.</p>
<p>Packages are all submodules of spack.packages.  If spack is installed
in $prefix, all of its python files are in $prefix/lib/spack.  Most
of them are in the spack module, so all the packages live in
$prefix/lib/spack/spack/packages.</p>
<p>All you have to do to create a package is make a new subclass of Package
in this directory.  Spack automatically scans the python files there
and figures out which one to import when you invoke it.</p>
<p><strong>An example package</strong></p>
<p>Let&#8217;s look at the cmake package to start with.  This package lives in
$prefix/lib/spack/spack/packages/cmake.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">spack</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">class</span> <span class="nc">Cmake</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="n">homepage</span>  <span class="o">=</span> <span class="s">&#39;https://www.cmake.org&#39;</span>
    <span class="n">url</span>       <span class="o">=</span> <span class="s">&#39;http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz&#39;</span>
    <span class="n">md5</span>       <span class="o">=</span> <span class="s">&#39;097278785da7182ec0aea8769d06860c&#39;</span>

    <span class="k">def</span> <span class="nf">install</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="n">configure</span><span class="p">(</span><span class="s">&#39;--prefix=</span><span class="si">%s</span><span class="s">&#39;</span>   <span class="o">%</span> <span class="n">prefix</span><span class="p">,</span>
                  <span class="s">&#39;--parallel=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">make_jobs</span><span class="p">)</span>
        <span class="n">make</span><span class="p">()</span>
        <span class="n">make</span><span class="p">(</span><span class="s">&#39;install&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Naming conventions</strong></p>
<p>There are two names you should care about:</p>
<ol class="arabic">
<li><p class="first">The module name, <tt class="docutils literal"><span class="pre">cmake</span></tt>.</p>
<ul class="simple">
<li>User will refers to this name, e.g. &#8216;spack install cmake&#8217;.</li>
<li>Corresponds to the name of the file, &#8216;cmake.py&#8217;, and it can
include <tt class="docutils literal"><span class="pre">_</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, and numbers (it can even start with a
number).</li>
</ul>
</li>
<li><p class="first">The class name, &#8220;Cmake&#8221;.  This is formed by converting <cite>-</cite> or
<tt class="docutils literal"><span class="pre">_</span></tt> in the module name to camel case.  If the name starts with
a number, we prefix the class name with <tt class="docutils literal"><span class="pre">Num_</span></tt>. Examples:</p>
<blockquote>
<div><blockquote>
<div><dl class="docutils">
<dt>Module Name       Class Name</dt>
<dd><p class="first last">foo_bar           FooBar
docbook-xml       DocbookXml
FooBar            Foobar
3proxy            Num_3proxy</p>
</dd>
</dl>
</div></blockquote>
<p>The class name is what spack looks for when it loads a package module.</p>
</div></blockquote>
</li>
</ol>
<p><strong>Required Attributes</strong></p>
<p>Aside from proper naming, here is the bare minimum set of things you
need when you make a package:</p>
<dl class="docutils">
<dt>homepage</dt>
<dd>informational URL, so that users know what they&#8217;re
installing.</dd>
<dt>url</dt>
<dd>URL of the source archive that spack will fetch.</dd>
<dt>install()</dt>
<dd>This function tells spack how to build and install the
software it downloaded.</dd>
</dl>
<p><strong>Optional Attributes</strong></p>
<p>You can also optionally add these attributes, if needed:</p>
<blockquote>
<div><dl class="docutils">
<dt>list_url</dt>
<dd>Webpage to scrape for available version strings. Default is the
directory containing the tarball; use this if the default isn&#8217;t
correct so that invoking &#8216;spack versions&#8217; will work for this
package.</dd>
<dt>url_version(self, version)</dt>
<dd>When spack downloads packages at particular versions, it just
converts version to string with str(version).  Override this if
your package needs special version formatting in its URL.  boost
is an example of a package that needs this.</dd>
</dl>
</div></blockquote>
<p><strong>*Creating Packages*</strong></p>
<p>As a package creator, you can probably ignore most of the preceding
information, because you can use the &#8216;spack create&#8217; command to do it
all automatically.</p>
<p>You as the package creator generally only have to worry about writing
your install function and specifying dependencies.</p>
<p><strong>spack create</strong></p>
<dl class="docutils">
<dt>Most software comes in nicely packaged tarballs, like this one:</dt>
<dd><a class="reference external" href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></dd>
</dl>
<p>Taking a page from homebrew, spack deduces pretty much everything it
needs to know from the URL above.  If you simply type this:</p>
<blockquote>
<div>spack create <a class="reference external" href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></div></blockquote>
<p>Spack will download the tarball, generate an md5 hash, figure out the
version and the name of the package from the URL, and create a new
package file for you with all the names and attributes set correctly.</p>
<p>Once this skeleton code is generated, spack pops up the new package in
your $EDITOR so that you can modify the parts that need changes.</p>
<p><strong>Dependencies</strong></p>
<p>If your package requires another in order to build, you can specify that
like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Stackwalker</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">depends_on</span><span class="p">(</span><span class="s">&quot;libdwarf&quot;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This tells spack that before it builds stackwalker, it needs to build
the libdwarf package as well.  Note that this is the module name, not
the class name (The class name is really only used by spack to find
your package).</p>
<p>Spack will download an install each dependency before it installs your
package.  In addtion, it will add -L, -I, and rpath arguments to your
compiler and linker for each dependency.  In most cases, this allows you
to avoid specifying any dependencies in your configure or cmake line;
you can just run configure or cmake without any additional arguments and
it will find the dependencies automatically.</p>
<p><strong>The Install Function</strong></p>
<p>The install function is designed so that someone not too terribly familiar
with Python could write a package installer.  For example, we put a number
of commands in install scope that you can use almost like shell commands.
These include make, configure, cmake, rm, rmtree, mkdir, mkdirp, and others.</p>
<p>You can see above in the cmake script that these commands are used to run
configure and make almost like they&#8217;re used on the command line.  The
only difference is that they are python function calls and not shell
commands.</p>
<p>It may be puzzling to you where the commands and functions in install live.
They are NOT instance variables on the class; this would require us to
type &#8216;self.&#8217; all the time and it makes the install code unnecessarily long.
Rather, spack puts these commands and variables in <em>module</em> scope for your
Package subclass.  Since each package has its own module, this doesn&#8217;t
pollute other namespaces, and it allows you to more easily implement an
install function.</p>
<p>For a full list of commands and variables available in module scope, see the
add_commands_to_module() function in this class. This is where most of
them are created and set on the module.</p>
<p><strong>Parallel Builds</strong></p>
<p>By default, Spack will run make in parallel when you run make() in your
install function.  Spack figures out how many cores are available on
your system and runs make with -j&lt;cores&gt;.  If you do not want this behavior,
you can explicitly mark a package not to use parallel make:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">SomePackage</span><span class="p">(</span><span class="n">Package</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">parallel</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This changes thd default behavior so that make is sequential.  If you still
want to build some parts in parallel, you can do this in your install function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">make</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Likewise, if you do not supply parallel = True in your Package, you can keep
the default parallel behavior and run make like this when you want a
sequential build:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">make</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Package Lifecycle</strong></p>
<p>This section is really only for developers of new spack commands.</p>
<p>A package&#8217;s lifecycle over a run of Spack looks something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Package</span><span class="p">()</span>             <span class="c"># Done for you by spack</span>

<span class="n">p</span><span class="o">.</span><span class="n">do_fetch</span><span class="p">()</span>              <span class="c"># called by spack commands in spack/cmd.</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_stage</span><span class="p">()</span>              <span class="c"># see spack.stage.Stage docs.</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_install</span><span class="p">()</span>            <span class="c"># calls package&#39;s install() function</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_uninstall</span><span class="p">()</span>
</pre></div>
</div>
<p>There are also some other commands that clean the build area:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">p</span><span class="o">.</span><span class="n">do_clean</span><span class="p">()</span>              <span class="c"># runs make clean</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_clean_work</span><span class="p">()</span>         <span class="c"># removes the build directory and</span>
                          <span class="c"># re-expands the archive.</span>
<span class="n">p</span><span class="o">.</span><span class="n">do_clean_dist</span><span class="p">()</span>         <span class="c"># removes the stage directory entirely</span>
</pre></div>
</div>
<p>The convention used here is that a do_* function is intended to be called
internally by Spack commands (in spack.cmd).  These aren&#8217;t for package
writers to override, and doing so may break the functionality of the Package
class.</p>
<p>Package creators override functions like install() (all of them do this),
clean() (some of them do this), and others to provide custom behavior.</p>
<dl class="method">
<dt id="spack.package.Package.add_commands_to_module">
<tt class="descname">add_commands_to_module</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.add_commands_to_module" title="Permalink to this definition">¶</a></dt>
<dd><p>Populate the module scope of install() with some useful functions.
This makes things easier for package writers.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.available_versions">
<tt class="descname">available_versions</tt><a class="headerlink" href="#spack.package.Package.available_versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.clean">
<tt class="descname">clean</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>By default just runs make clean.  Override if this isn&#8217;t good.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.conflicted">
<tt class="descname">conflicted</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.conflicted" title="Permalink to this definition">¶</a></dt>
<dd><p>By default we build in parallel.  Subclasses can override this.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.default_version">
<tt class="descname">default_version</tt><a class="headerlink" href="#spack.package.Package.default_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the version in the default URL for this package,
or fails.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.dependencies">
<tt class="descname">dependencies</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Specs of virtual packages provided by this package, keyed by name.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.dirty">
<tt class="descname">dirty</tt><em class="property"> = False</em><a class="headerlink" href="#spack.package.Package.dirty" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether install and uninstall check deps before running.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_clean">
<tt class="descname">do_clean</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_clean_dist">
<tt class="descname">do_clean_dist</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_clean_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the stage directory where this package was built.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_clean_work">
<tt class="descname">do_clean_work</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_clean_work" title="Permalink to this definition">¶</a></dt>
<dd><p>By default just blows away the stage directory and re-stages.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_fetch">
<tt class="descname">do_fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a stage directory and downloads the taball for this package.
Working directory will be set to the stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_install">
<tt class="descname">do_install</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_install" title="Permalink to this definition">¶</a></dt>
<dd><p>This class should call this version of the install method.
Package implementations should override install().</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_install_dependencies">
<tt class="descname">do_install_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_install_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_stage">
<tt class="descname">do_stage</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks the fetched tarball, then changes into the expanded tarball
directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.do_uninstall">
<tt class="descname">do_uninstall</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.do_uninstall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.fetch_available_versions">
<tt class="descname">fetch_available_versions</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.fetch_available_versions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.ignore_dependencies">
<tt class="descname">ignore_dependencies</tt><em class="property"> = False</em><a class="headerlink" href="#spack.package.Package.ignore_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.install">
<tt class="descname">install</tt><big>(</big><em>spec</em>, <em>prefix</em><big>)</big><a class="headerlink" href="#spack.package.Package.install" title="Permalink to this definition">¶</a></dt>
<dd><p>Package implementations override this with their own build configuration.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.installed">
<tt class="descname">installed</tt><a class="headerlink" href="#spack.package.Package.installed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.installed_dependents">
<tt class="descname">installed_dependents</tt><a class="headerlink" href="#spack.package.Package.installed_dependents" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the specs of all installed packages that depend
on this one.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.module">
<tt class="descname">module</tt><a class="headerlink" href="#spack.package.Package.module" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this to add variables to the class&#8217;s module&#8217;s scope.
This lets us use custom syntax in the install method.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.parallel">
<tt class="descname">parallel</tt><em class="property"> = True</em><a class="headerlink" href="#spack.package.Package.parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove tarball and build by default.  If this is true, leave them.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.prefix">
<tt class="descname">prefix</tt><a class="headerlink" href="#spack.package.Package.prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the prefix into which this package should be installed.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.preorder_traversal">
<tt class="descname">preorder_traversal</tt><big>(</big><em>visited=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.package.Package.preorder_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>This does a preorder traversal of the package&#8217;s dependence DAG.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.provided">
<tt class="descname">provided</tt><em class="property"> = {}</em><a class="headerlink" href="#spack.package.Package.provided" title="Permalink to this definition">¶</a></dt>
<dd><p>Specs of conflicting packages, keyed by name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.provides">
<tt class="descname">provides</tt><big>(</big><em>vpkg_name</em><big>)</big><a class="headerlink" href="#spack.package.Package.provides" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this package provides a virtual package with the specified name.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.remove_prefix">
<tt class="descname">remove_prefix</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.remove_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the prefix for a package along with any empty parent directories.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.setup_install_environment">
<tt class="descname">setup_install_environment</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.setup_install_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>This ensures a clean install environment when we build packages.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.stage">
<tt class="descname">stage</tt><a class="headerlink" href="#spack.package.Package.stage" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.url_for_version">
<tt class="descname">url_for_version</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.package.Package.url_for_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a URL that you can download a new version of this package from.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.url_version">
<tt class="descname">url_version</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.package.Package.url_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a version, this returns a string that should be substituted into the
package&#8217;s URL to download that version.
By default, this just returns the version string. Subclasses may need to
override this, e.g. for boost versions where you need to ensure that there
are _&#8217;s in the download URL.</p>
</dd></dl>

<dl class="method">
<dt id="spack.package.Package.validate_dependencies">
<tt class="descname">validate_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.package.Package.validate_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure that this package and its dependencies all have consistent
constraints on them.</p>
<p>NOTE that this will NOT find sanity problems through a virtual
dependency.  Virtual deps complicate the problem because we
don&#8217;t know in advance which ones conflict with others in the
dependency DAG. If there&#8217;s more than one virtual dependency,
it&#8217;s a full-on SAT problem, so hold off on this for now.
The vdeps are actually skipped in preorder_traversal, so see
that for details.</p>
<p>TODO: investigate validating virtual dependencies.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.package.Package.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.package.Package.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.package.Package.virtual_dependencies">
<tt class="descname">virtual_dependencies</tt><big>(</big><em>visited=None</em><big>)</big><a class="headerlink" href="#spack.package.Package.virtual_dependencies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.package.find_versions_of_archive">
<tt class="descclassname">spack.package.</tt><tt class="descname">find_versions_of_archive</tt><big>(</big><em>archive_url</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.package.find_versions_of_archive" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-spack.parse">
<span id="parse-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt> Module<a class="headerlink" href="#module-spack.parse" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.parse.LexError">
<em class="property">exception </em><tt class="descclassname">spack.parse.</tt><tt class="descname">LexError</tt><big>(</big><em>message</em>, <em>string</em>, <em>pos</em><big>)</big><a class="headerlink" href="#spack.parse.LexError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.parse.ParseError" title="spack.parse.ParseError"><tt class="xref py py-class docutils literal"><span class="pre">spack.parse.ParseError</span></tt></a></p>
<p>Raised when we don&#8217;t know how to lex something.</p>
</dd></dl>

<dl class="class">
<dt id="spack.parse.Lexer">
<em class="property">class </em><tt class="descclassname">spack.parse.</tt><tt class="descname">Lexer</tt><big>(</big><em>lexicon</em><big>)</big><a class="headerlink" href="#spack.parse.Lexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for Lexers that keep track of line numbers.</p>
<dl class="method">
<dt id="spack.parse.Lexer.lex">
<tt class="descname">lex</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.parse.Lexer.lex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.parse.Lexer.token">
<tt class="descname">token</tt><big>(</big><em>type</em>, <em>value=''</em><big>)</big><a class="headerlink" href="#spack.parse.Lexer.token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.parse.ParseError">
<em class="property">exception </em><tt class="descclassname">spack.parse.</tt><tt class="descname">ParseError</tt><big>(</big><em>message</em>, <em>string</em>, <em>pos</em><big>)</big><a class="headerlink" href="#spack.parse.ParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when we don&#8217;t hit an error while parsing.</p>
</dd></dl>

<dl class="class">
<dt id="spack.parse.Parser">
<em class="property">class </em><tt class="descclassname">spack.parse.</tt><tt class="descname">Parser</tt><big>(</big><em>lexer</em><big>)</big><a class="headerlink" href="#spack.parse.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for simple recursive descent parsers.</p>
<dl class="method">
<dt id="spack.parse.Parser.accept">
<tt class="descname">accept</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.accept" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts the next symbol in self.token if we like it.  Then calls gettok()</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.expect">
<tt class="descname">expect</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Like accept(), but fails if we don&#8217;t like the next token.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.gettok">
<tt class="descname">gettok</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.parse.Parser.gettok" title="Permalink to this definition">¶</a></dt>
<dd><p>Puts the next token in the input stream into self.next.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.last_token_error">
<tt class="descname">last_token_error</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.last_token_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an error about the previous token in the stream.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.next_token_error">
<tt class="descname">next_token_error</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.next_token_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an error about the next token in the stream.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.parse">
<tt class="descname">parse</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.push_tokens">
<tt class="descname">push_tokens</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.push_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds all tokens in some iterable to the token stream.</p>
</dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.setup">
<tt class="descname">setup</tt><big>(</big><em>text</em><big>)</big><a class="headerlink" href="#spack.parse.Parser.setup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.parse.Parser.unexpected_token">
<tt class="descname">unexpected_token</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.parse.Parser.unexpected_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.parse.Token">
<em class="property">class </em><tt class="descclassname">spack.parse.</tt><tt class="descname">Token</tt><big>(</big><em>type</em>, <em>value=''</em>, <em>start=0</em>, <em>end=0</em><big>)</big><a class="headerlink" href="#spack.parse.Token" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents tokens; generated from input by lexer and fed to parse().</p>
<dl class="method">
<dt id="spack.parse.Token.is_a">
<tt class="descname">is_a</tt><big>(</big><em>type</em><big>)</big><a class="headerlink" href="#spack.parse.Token.is_a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-spack.relations">
<span id="relations-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">relations</span></tt> Module<a class="headerlink" href="#module-spack.relations" title="Permalink to this headline">¶</a></h2>
<p>This package contains relationships that can be defined among packages.
Relations are functions that can be called inside a package definition,
for example:</p>
<blockquote>
<div><dl class="docutils">
<dt>class OpenMPI(Package):</dt>
<dd>depends_on(&#8220;hwloc&#8221;)
provides(&#8220;mpi&#8221;)
...</dd>
</dl>
</div></blockquote>
<p>The available relations are:</p>
<dl class="docutils">
<dt>depends_on</dt>
<dd>Above, the OpenMPI package declares that it &#8220;depends on&#8221; hwloc.  This means
that the hwloc package needs to be installed before OpenMPI can be
installed.  When a user runs &#8216;spack install openmpi&#8217;, spack will fetch
hwloc and install it first.</dd>
<dt>provides</dt>
<dd><p class="first">This is useful when more than one package can satisfy a dependence.  Above,
OpenMPI declares that it &#8220;provides&#8221; mpi.  Other implementations of the MPI
interface, like mvapich and mpich, also provide mpi, e.g.:</p>
<blockquote>
<div><dl class="docutils">
<dt>class Mvapich(Package):</dt>
<dd>provides(&#8220;mpi&#8221;)
...</dd>
<dt>class Mpich(Package):</dt>
<dd>provides(&#8220;mpi&#8221;)
...</dd>
</dl>
</div></blockquote>
<p>Instead of depending on openmpi, mvapich, or mpich, another package can
declare that it depends on &#8220;mpi&#8221;:</p>
<blockquote>
<div><dl class="docutils">
<dt>class Mpileaks(Package):</dt>
<dd>depends_on(&#8220;mpi&#8221;)
...</dd>
</dl>
</div></blockquote>
<p>Now the user can pick which MPI they would like to build with when they
install mpileaks.  For example, the user could install 3 instances of
mpileaks, one for each MPI version, by issuing these three commands:</p>
<blockquote class="last">
<div>spack install mpileaks ^openmpi
spack install mpileaks ^mvapich
spack install mpileaks ^mpich</div></blockquote>
</dd>
</dl>
<dl class="exception">
<dt id="spack.relations.CircularReferenceError">
<em class="property">exception </em><tt class="descclassname">spack.relations.</tt><tt class="descname">CircularReferenceError</tt><big>(</big><em>relation</em>, <em>package</em><big>)</big><a class="headerlink" href="#spack.relations.CircularReferenceError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.relations.RelationError" title="spack.relations.RelationError"><tt class="xref py py-class docutils literal"><span class="pre">spack.relations.RelationError</span></tt></a></p>
<p>This is raised when something depends on itself.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.relations.RelationError">
<em class="property">exception </em><tt class="descclassname">spack.relations.</tt><tt class="descname">RelationError</tt><big>(</big><em>relation</em>, <em>message</em><big>)</big><a class="headerlink" href="#spack.relations.RelationError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>This is raised when something is wrong with a package relation.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.relations.ScopeError">
<em class="property">exception </em><tt class="descclassname">spack.relations.</tt><tt class="descname">ScopeError</tt><big>(</big><em>relation</em><big>)</big><a class="headerlink" href="#spack.relations.ScopeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.relations.RelationError" title="spack.relations.RelationError"><tt class="xref py py-class docutils literal"><span class="pre">spack.relations.RelationError</span></tt></a></p>
<p>This is raised when a relation is called from outside a spack package.</p>
</dd></dl>

<dl class="function">
<dt id="spack.relations.conflicts">
<tt class="descclassname">spack.relations.</tt><tt class="descname">conflicts</tt><big>(</big><em>*specs</em><big>)</big><a class="headerlink" href="#spack.relations.conflicts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.relations.depends_on">
<tt class="descclassname">spack.relations.</tt><tt class="descname">depends_on</tt><big>(</big><em>*specs</em><big>)</big><a class="headerlink" href="#spack.relations.depends_on" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.relations.provides">
<tt class="descclassname">spack.relations.</tt><tt class="descname">provides</tt><big>(</big><em>*specs</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.relations.provides" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows packages to provide a virtual dependency.  If a package provides
&#8216;mpi&#8217;, other packages can declare that they depend on &#8220;mpi&#8221;, and spack
can use the providing package to satisfy the dependency.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.spec">
<span id="spec-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">spec</span></tt> Module<a class="headerlink" href="#module-spack.spec" title="Permalink to this headline">¶</a></h2>
<p>Spack allows very fine-grained control over how packages are installed and
over how they are built and configured.  To make this easy, it has its own
syntax for declaring a dependence.  We call a descriptor of a particular
package configuration a &#8220;spec&#8221;.</p>
<p>The syntax looks like this:</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$ </span>spack install mpileaks ^openmpi @1.2:1.4 +debug %intel @12.1 <span class="o">=</span>bgqos_0
                0        1        2        3      4      5     6
</pre></div>
</div>
<p>The first part of this is the command, &#8216;spack install&#8217;.  The rest of the
line is a spec for a particular installation of the mpileaks package.</p>
<ol class="arabic" start="0">
<li><p class="first">The package to install</p>
</li>
<li><p class="first">A dependency of the package, prefixed by ^</p>
</li>
<li><p class="first">A version descriptor for the package.  This can either be a specific
version, like &#8220;1.2&#8221;, or it can be a range of versions, e.g. &#8220;1.2:1.4&#8221;.
If multiple specific versions or multiple ranges are acceptable, they
can be separated by commas, e.g. if a package will only build with
versions 1.0, 1.2-1.4, and 1.6-1.8 of mavpich, you could say:</p>
<blockquote>
<div><p>depends_on(&#8220;<a class="reference external" href="mailto:mvapich&#37;&#52;&#48;1&#46;0">mvapich<span>&#64;</span>1<span>&#46;</span>0</a>,1.2:1.4,1.6:1.8&#8221;)</p>
</div></blockquote>
</li>
<li><p class="first">A compile-time variant of the package.  If you need openmpi to be
built in debug mode for your package to work, you can require it by
adding +debug to the openmpi spec when you depend on it.  If you do
NOT want the debug option to be enabled, then replace this with -debug.</p>
</li>
<li><p class="first">The name of the compiler to build with.</p>
</li>
<li><p class="first">The versions of the compiler to build with.  Note that the identifier
for a compiler version is the same &#8216;&#64;&#8217; that is used for a package version.
A version list denoted by &#8216;&#64;&#8217; is associated with the compiler only if
if it comes immediately after the compiler name.  Otherwise it will be
associated with the current package spec.</p>
</li>
<li><p class="first">The architecture to build with.  This is needed on machines where
cross-compilation is required</p>
</li>
</ol>
<p>Here is the EBNF grammar for a spec:</p>
<div class="highlight-python"><pre>spec-list    = { spec [ dep-list ] }
dep_list     = { ^ spec }
spec         = id [ options ]
options      = { @version-list | +variant | -variant | ~variant |
                 %compiler | =architecture }
variant      = id
architecture = id
compiler     = id [ version-list ]
version-list = version [ { , version } ]
version      = id | id: | :id | id:id
id           = [A-Za-z0-9_][A-Za-z0-9_.-]*</pre>
</div>
<p>There is one context-sensitive part: ids in versions may contain &#8216;.&#8217;, while
other ids may not.</p>
<p>There is one ambiguity: since &#8216;-&#8216; is allowed in an id, you need to put
whitespace space before -variant for it to be tokenized properly.  You can
either use whitespace, or you can just use ~variant since it means the same
thing.  Spack uses ~variant in directory names and in the canonical form of
specs to avoid ambiguity.  Both are provided because ~ can cause shell
expansion when it is the first character in an id typed on the command line.</p>
<dl class="class">
<dt id="spack.spec.Compiler">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">Compiler</tt><big>(</big><em>name</em>, <em>version=None</em><big>)</big><a class="headerlink" href="#spack.spec.Compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The Compiler field represents the compiler or range of compiler
versions that a package should be built with.  Compilers have a
name and a version list.</p>
<dl class="attribute">
<dt id="spack.spec.Compiler.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.spec.Compiler.concrete" title="Permalink to this definition">¶</a></dt>
<dd><p>A Compiler spec is concrete if its versions are concrete.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Compiler.constrain">
<tt class="descname">constrain</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Compiler.constrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Compiler.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Compiler.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Compiler.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Compiler.satisfies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.Compiler.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.spec.Compiler.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.spec.DependencyMap">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DependencyMap</tt><a class="headerlink" href="#spack.spec.DependencyMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="spack.util.html#spack.util.lang.HashableMap" title="spack.util.lang.HashableMap"><tt class="xref py py-class docutils literal"><span class="pre">spack.util.lang.HashableMap</span></tt></a></p>
<p>Each spec has a DependencyMap containing specs for its dependencies.
The DependencyMap is keyed by name.</p>
<dl class="attribute">
<dt id="spack.spec.DependencyMap.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.spec.DependencyMap.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.DependencyMap.sha1">
<tt class="descname">sha1</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.DependencyMap.sha1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateArchitectureError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateArchitectureError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateArchitectureError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same architecture occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateCompilerError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateCompilerError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateCompilerError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same compiler occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateDependencyError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateDependencyError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateDependencyError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same dependency occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.DuplicateVariantError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">DuplicateVariantError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.DuplicateVariantError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the same variant occurs in a spec twice.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.InconsistentSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">InconsistentSpecError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.InconsistentSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when two nodes in the same spec DAG have inconsistent
constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.InvalidDependencyException">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">InvalidDependencyException</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.InvalidDependencyException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when a dependency in a spec is not actually a dependency
of the package.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.MultipleProviderError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">MultipleProviderError</tt><big>(</big><em>vpkg</em>, <em>providers</em><big>)</big><a class="headerlink" href="#spack.spec.MultipleProviderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when there is no package that provides a particular
virtual dependency.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.NoProviderError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">NoProviderError</tt><big>(</big><em>vpkg</em><big>)</big><a class="headerlink" href="#spack.spec.NoProviderError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when there is no package that provides a particular
virtual dependency.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.Spec">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">Spec</tt><big>(</big><em>spec_like</em>, <em>*dep_like</em><big>)</big><a class="headerlink" href="#spack.spec.Spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="method">
<dt id="spack.spec.Spec.colorized">
<tt class="descname">colorized</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.colorized" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.common_dependencies">
<tt class="descname">common_dependencies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.common_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return names of dependencies that self an other have in common.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.spec.Spec.concrete" title="Permalink to this definition">¶</a></dt>
<dd><p>A spec is concrete if it can describe only ONE build of a package.
If any of the name, version, architecture, compiler, or depdenencies
are ambiguous,then it is not concrete.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.concretize">
<tt class="descname">concretize</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.concretize" title="Permalink to this definition">¶</a></dt>
<dd><p>A spec is concrete if it describes one build of a package uniquely.
This will ensure that this spec is concrete.</p>
<p>If this spec could describe more than one version, variant, or build
of a package, this will add constraints to make it concrete.</p>
<p>Some rigorous validation and checks are also performed on the spec.
Concretizing ensures that it is self-consistent and that it&#8217;s consistent
with requirements of its pacakges.  See flatten() and normalize() for
more details on this.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.concretized">
<tt class="descname">concretized</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.concretized" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a non-destructive version of concretize().  First clones,
then returns a concrete version of this package without modifying
this package.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.constrain">
<tt class="descname">constrain</tt><big>(</big><em>other</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.constrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.copy">
<tt class="descname">copy</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of this spec.
By default, returns a deep copy.  Supply dependencies=False
to get a shallow copy.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.dep_difference">
<tt class="descname">dep_difference</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.dep_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns dependencies in self that are not in other.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.flat_dependencies">
<tt class="descname">flat_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.flat_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a DependencyMap containing all of this spec&#8217;s dependencies
with their constraints merged.  If there are any conflicts, throw
an exception.</p>
<p>This will work even on specs that are not normalized; i.e. specs
that have two instances of the same dependency in the DAG.
This is used as the first step of normalization.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.flatten">
<tt class="descname">flatten</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Pull all dependencies up to the root (this spec).
Merge constraints for dependencies with the same name, and if they
conflict, throw an exception.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.format">
<tt class="descname">format</tt><big>(</big><em>format_string='$_$&#64;$%&#64;$+$='</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints out particular pieces of a spec, depending on what is
in the format string.  The format strings you can provide are:</p>
<div class="highlight-python"><pre>$_   Package name
$@   Version
$%   Compiler
$%@  Compiler &amp; compiler version
$+   Options
$=   Architecture
$#   Dependencies' 6-char sha1 prefix
$$   $</pre>
</div>
<p>Anything else is copied verbatim into the output stream.</p>
<p><em>Example:</em>  <tt class="docutils literal"><span class="pre">$_$&#64;$+</span></tt> translates to the name, version, and options
of the package, but no dependencies, arch, or compiler.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.normalize">
<tt class="descname">normalize</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>When specs are parsed, any dependencies specified are hanging off
the root, and ONLY the ones that were explicitly provided are there.
Normalization turns a partial flat spec into a DAG, where:</p>
<ol class="arabic simple">
<li>ALL dependencies of the root package are in the DAG.</li>
<li>Each node&#8217;s dependencies dict only contains its direct deps.</li>
<li>There is only ONE unique spec for each package in the DAG.<ul>
<li>This includes virtual packages.  If there a non-virtual
package that provides a virtual package that is in the spec,
then we replace the virtual package with the non-virtual one.</li>
</ul>
</li>
<li>The spec DAG matches package DAG.</li>
</ol>
<p>TODO: normalize should probably implement some form of cycle detection,
to ensure that the spec is actually a DAG.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.normalized">
<tt class="descname">normalized</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.normalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a normalized copy of this spec without modifying this spec.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.package">
<tt class="descname">package</tt><a class="headerlink" href="#spack.spec.Spec.package" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.prefix">
<tt class="descname">prefix</tt><a class="headerlink" href="#spack.spec.Spec.prefix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.preorder_traversal">
<tt class="descname">preorder_traversal</tt><big>(</big><em>visited=None</em>, <em>d=0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.preorder_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic preorder traversal of the DAG represented by this spec.
This will yield each node in the spec.  Options:</p>
<dl class="docutils">
<dt>cover    [=nodes|edges|paths]</dt>
<dd><p class="first">Determines how extensively to cover the dag.  Possible vlaues:</p>
<dl class="last docutils">
<dt>&#8216;nodes&#8217;: Visit each node in the dag only once.  Every node</dt>
<dd>yielded by this function will be unique.</dd>
<dt>&#8216;edges&#8217;: If a node has been visited once but is reached along a</dt>
<dd>new path from the root, yield it but do not descend
into it.  This traverses each &#8216;edge&#8217; in the DAG once.</dd>
<dt>&#8216;paths&#8217;: Explore every unique path reachable from the root.</dt>
<dd>This descends into visited subtrees and will yield
nodes twice if they&#8217;re reachable by multiple paths.</dd>
</dl>
</dd>
<dt>depth    [=False]</dt>
<dd>Defaults to False.  When True, yields not just nodes in the
spec, but also their depth from the root in a (depth, node)
tuple.</dd>
<dt>keyfun   [=id]</dt>
<dd>Allow a custom key function to track the identity of nodes
in the traversal.</dd>
<dt>root     [=True]</dt>
<dd>If false, this won&#8217;t yield the root node, just its descendents.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.root">
<tt class="descname">root</tt><a class="headerlink" href="#spack.spec.Spec.root" title="Permalink to this definition">¶</a></dt>
<dd><p>Follow dependent links and find the root of this spec&#8217;s DAG.
In spack specs, there should be a single root (the package being
installed).  This will throw an assertion error if that is not
the case.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.satisfies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.satisfies_dependencies">
<tt class="descname">satisfies_dependencies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.satisfies_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>This checks constraints on common dependencies against each other.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.sha1">
<tt class="descname">sha1</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.sha1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.tree">
<tt class="descname">tree</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.spec.Spec.tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints out this spec and its dependencies, tree-formatted
with indentation.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.validate_names">
<tt class="descname">validate_names</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.validate_names" title="Permalink to this definition">¶</a></dt>
<dd><p>This checks that names of packages and compilers in this spec are real.
If they&#8217;re not, it will raise either UnknownPackageError or
UnknownCompilerError.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.version">
<tt class="descname">version</tt><a class="headerlink" href="#spack.spec.Spec.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.spec.Spec.virtual">
<tt class="descname">virtual</tt><a class="headerlink" href="#spack.spec.Spec.virtual" title="Permalink to this definition">¶</a></dt>
<dd><p>Right now, a spec is virtual if no package exists with its name.</p>
<p>TODO: revisit this &#8211; might need to use a separate namespace and
be more explicit about this.
Possible idea: just use conventin and make virtual deps all
caps, e.g., MPI vs mpi.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.Spec.virtual_dependencies">
<tt class="descname">virtual_dependencies</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Spec.virtual_dependencies" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of any virtual deps in this spec.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.spec.SpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecError</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.spec.SpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Superclass for all errors that occur while constructing specs.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.SpecLexer">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecLexer</tt><a class="headerlink" href="#spack.spec.SpecLexer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.parse.Lexer" title="spack.parse.Lexer"><tt class="xref py py-class docutils literal"><span class="pre">spack.parse.Lexer</span></tt></a></p>
<p>Parses tokens that make up spack specs.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.SpecParseError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecParseError</tt><big>(</big><em>parse_error</em><big>)</big><a class="headerlink" href="#spack.spec.SpecParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Wrapper for ParseError for when we&#8217;re parsing specs.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.SpecParser">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">SpecParser</tt><a class="headerlink" href="#spack.spec.SpecParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.parse.Parser" title="spack.parse.Parser"><tt class="xref py py-class docutils literal"><span class="pre">spack.parse.Parser</span></tt></a></p>
<dl class="method">
<dt id="spack.spec.SpecParser.architecture">
<tt class="descname">architecture</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.architecture" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.check_identifier">
<tt class="descname">check_identifier</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.check_identifier" title="Permalink to this definition">¶</a></dt>
<dd><p>The only identifiers that can contain &#8216;.&#8217; are versions, but version
ids are context-sensitive so we have to check on a case-by-case
basis. Call this if we detect a version id where it shouldn&#8217;t be.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.compiler">
<tt class="descname">compiler</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.compiler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.do_parse">
<tt class="descname">do_parse</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.do_parse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.spec">
<tt class="descname">spec</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a spec out of the input.  If a spec is supplied, then initialize
and return it instead of creating a new one.</p>
</dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.variant">
<tt class="descname">variant</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.variant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.version">
<tt class="descname">version</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.spec.SpecParser.version_list">
<tt class="descname">version_list</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.SpecParser.version_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnknownCompilerError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnknownCompilerError</tt><big>(</big><em>compiler_name</em><big>)</big><a class="headerlink" href="#spack.spec.UnknownCompilerError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when the user asks for a compiler spack doesn&#8217;t know about.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableArchitectureSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableArchitectureSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableArchitectureSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec architecture conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableCompilerSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableCompilerSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableCompilerSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec comiler conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableDependencySpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableDependencySpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableDependencySpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when some dependency of constrained specs are incompatible</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableProviderSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableProviderSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableProviderSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a provider is supplied but constraints don&#8217;t match
a vpkg requirement</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableSpecError</tt><big>(</big><em>provided</em>, <em>required</em>, <em>constraint_type</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.SpecError" title="spack.spec.SpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.SpecError</span></tt></a></p>
<p>Raised when a spec conflicts with package constraints.
Provide the requirement that was violated when raising.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableSpecNameError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableSpecNameError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableSpecNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when two specs aren&#8217;t even for the same package.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableVariantSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableVariantSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableVariantSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec variant conflicts with package constraints.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.spec.UnsatisfiableVersionSpecError">
<em class="property">exception </em><tt class="descclassname">spack.spec.</tt><tt class="descname">UnsatisfiableVersionSpecError</tt><big>(</big><em>provided</em>, <em>required</em><big>)</big><a class="headerlink" href="#spack.spec.UnsatisfiableVersionSpecError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.spec.UnsatisfiableSpecError" title="spack.spec.UnsatisfiableSpecError"><tt class="xref py py-class docutils literal"><span class="pre">spack.spec.UnsatisfiableSpecError</span></tt></a></p>
<p>Raised when a spec version conflicts with package constraints.</p>
</dd></dl>

<dl class="class">
<dt id="spack.spec.Variant">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">Variant</tt><big>(</big><em>name</em>, <em>enabled</em><big>)</big><a class="headerlink" href="#spack.spec.Variant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Variants are named, build-time options for a package.  Names depend
on the particular package being built, and each named variant can
be enabled or disabled.</p>
<dl class="method">
<dt id="spack.spec.Variant.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.spec.Variant.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.spec.VariantMap">
<em class="property">class </em><tt class="descclassname">spack.spec.</tt><tt class="descname">VariantMap</tt><a class="headerlink" href="#spack.spec.VariantMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="spack.util.html#spack.util.lang.HashableMap" title="spack.util.lang.HashableMap"><tt class="xref py py-class docutils literal"><span class="pre">spack.util.lang.HashableMap</span></tt></a></p>
<dl class="method">
<dt id="spack.spec.VariantMap.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.spec.VariantMap.satisfies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="data">
<dt id="spack.spec.color_formats">
<tt class="descclassname">spack.spec.</tt><tt class="descname">color_formats</tt><em class="property"> = {'&#64;': '&#64;c', '%': '&#64;g', '+': '&#64;B', '~': '&#64;r', '=': '&#64;m', '^': '&#64;.'}</em><a class="headerlink" href="#spack.spec.color_formats" title="Permalink to this definition">¶</a></dt>
<dd><p>Regex used for splitting by spec field separators.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.colorize_spec">
<tt class="descclassname">spack.spec.</tt><tt class="descname">colorize_spec</tt><big>(</big><em>spec</em><big>)</big><a class="headerlink" href="#spack.spec.colorize_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a spec colorized according to the colors specified in
color_formats.</p>
</dd></dl>

<dl class="data">
<dt id="spack.spec.dependency_color">
<tt class="descclassname">spack.spec.</tt><tt class="descname">dependency_color</tt><em class="property"> = '&#64;.'</em><a class="headerlink" href="#spack.spec.dependency_color" title="Permalink to this definition">¶</a></dt>
<dd><p>This map determines the coloring of specs when using color output.
We make the fields different colors to enhance readability.
See spack.color for descriptions of the color codes.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.index_specs">
<tt class="descclassname">spack.spec.</tt><tt class="descname">index_specs</tt><big>(</big><em>specs</em><big>)</big><a class="headerlink" href="#spack.spec.index_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>Take a list of specs and return a dict of lists.  Dict is
keyed by spec name and lists include all specs with the
same name.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.parse">
<tt class="descclassname">spack.spec.</tt><tt class="descname">parse</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.spec.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of specs from an input string.
For creating one spec, see Spec() constructor.</p>
</dd></dl>

<dl class="function">
<dt id="spack.spec.parse_anonymous_spec">
<tt class="descclassname">spack.spec.</tt><tt class="descname">parse_anonymous_spec</tt><big>(</big><em>spec_like</em>, <em>pkg_name</em><big>)</big><a class="headerlink" href="#spack.spec.parse_anonymous_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow the user to omit the package name part of a spec if they
know what it has to be already.</p>
<p>e.g., provides(&#8216;mpi&#64;2&#8217;, <a class="reference external" href="mailto:when='&#37;&#52;&#48;1&#46;9">when='<span>&#64;</span>1<span>&#46;</span>9</a>:&#8217;) says that this package
provides MPI-3 when its version is higher than 1.9.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.stage">
<span id="stage-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">stage</span></tt> Module<a class="headerlink" href="#module-spack.stage" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="spack.stage.FailedDownloadError">
<em class="property">exception </em><tt class="descclassname">spack.stage.</tt><tt class="descname">FailedDownloadError</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#spack.stage.FailedDownloadError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised wen a download fails.</p>
</dd></dl>

<dl class="class">
<dt id="spack.stage.Stage">
<em class="property">class </em><tt class="descclassname">spack.stage.</tt><tt class="descname">Stage</tt><big>(</big><em>url</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#spack.stage.Stage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A Stage object manaages a directory where an archive is downloaded,
expanded, and built before being installed.  It also handles downloading
the archive.  A stage&#8217;s lifecycle looks like this:</p>
<dl class="docutils">
<dt>setup()</dt>
<dd>Create the stage directory.</dd>
<dt>fetch()</dt>
<dd>Fetch a source archive into the stage.</dd>
<dt>expand_archive()</dt>
<dd>Expand the source archive.</dd>
<dt>&lt;install&gt;</dt>
<dd>Build and install the archive.  This is handled by the Package class.</dd>
<dt>destroy()</dt>
<dd>Remove the stage once the package has been installed.</dd>
</dl>
<p>If spack.use_tmp_stage is True, spack will attempt to create stages
in a tmp directory.  Otherwise, stages are created directly in
spack.stage_path.</p>
<p>There are two kinds of stages: named and unnamed.  Named stages can
persist between runs of spack, e.g. if you fetched a tarball but
didn&#8217;t finish building it, you won&#8217;t have to fetch it again.</p>
<p>Unnamed stages are created using standard mkdtemp mechanisms or
similar, and are intended to persist for only one run of spack.</p>
<dl class="attribute">
<dt id="spack.stage.Stage.archive_file">
<tt class="descname">archive_file</tt><a class="headerlink" href="#spack.stage.Stage.archive_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Path to the source archive within this stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.chdir">
<tt class="descname">chdir</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.chdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes directory to the stage path.  Or dies if it is not set up.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.chdir_to_archive">
<tt class="descname">chdir_to_archive</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.chdir_to_archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes directory to the expanded archive directory.
Dies with an error if there was no expanded archive.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.destroy">
<tt class="descname">destroy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this stage directory.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.expand_archive">
<tt class="descname">expand_archive</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.expand_archive" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes to the stage directory and attempt to expand the downloaded
archive.  Fail if the stage is not set up or if the archive is not yet
downloaded.</p>
</dd></dl>

<dl class="attribute">
<dt id="spack.stage.Stage.expanded_archive_path">
<tt class="descname">expanded_archive_path</tt><a class="headerlink" href="#spack.stage.Stage.expanded_archive_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the expanded archive directory if it&#8217;s expanded;
None if the archive hasn&#8217;t been expanded.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.fetch">
<tt class="descname">fetch</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.fetch" title="Permalink to this definition">¶</a></dt>
<dd><p>Downloads the file at URL to the stage.  Returns true if it was downloaded,
false if it already existed.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.restage">
<tt class="descname">restage</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.restage" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the expanded archive path if it exists, then re-expands
the archive.</p>
</dd></dl>

<dl class="method">
<dt id="spack.stage.Stage.setup">
<tt class="descname">setup</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.Stage.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the stage directory.
If spack.use_tmp_stage is False, the stage directory is created
directly under spack.stage_path.</p>
<p>If spack.use_tmp_stage is True, this will attempt to create a
stage in a temporary directory and link it into spack.stage_path.
Spack will use the first writable location in spack.tmp_dirs to
create a stage.  If there is no valid location in tmp_dirs, fall
back to making the stage inside spack.stage_path.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.stage.ensure_access">
<tt class="descclassname">spack.stage.</tt><tt class="descname">ensure_access</tt><big>(</big><em>file='/Users/gamblin2/src/spack/var/spack/stage'</em><big>)</big><a class="headerlink" href="#spack.stage.ensure_access" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure we can access a directory and die with an error if we can&#8217;t.</p>
</dd></dl>

<dl class="function">
<dt id="spack.stage.find_tmp_root">
<tt class="descclassname">spack.stage.</tt><tt class="descname">find_tmp_root</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.find_tmp_root" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.stage.purge">
<tt class="descclassname">spack.stage.</tt><tt class="descname">purge</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.stage.purge" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all build directories in the top-level stage path.</p>
</dd></dl>

<dl class="function">
<dt id="spack.stage.remove_linked_tree">
<tt class="descclassname">spack.stage.</tt><tt class="descname">remove_linked_tree</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.stage.remove_linked_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a directory and its contents.  If the directory is a symlink,
follows the link and reamoves the real directory before removing the
link.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.tty">
<span id="tty-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">tty</span></tt> Module<a class="headerlink" href="#module-spack.tty" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spack.tty.debug">
<tt class="descclassname">spack.tty.</tt><tt class="descname">debug</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#spack.tty.debug" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.die">
<tt class="descclassname">spack.tty.</tt><tt class="descname">die</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#spack.tty.die" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.error">
<tt class="descclassname">spack.tty.</tt><tt class="descname">error</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#spack.tty.error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.get_number">
<tt class="descclassname">spack.tty.</tt><tt class="descname">get_number</tt><big>(</big><em>prompt</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.tty.get_number" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.info">
<tt class="descclassname">spack.tty.</tt><tt class="descname">info</tt><big>(</big><em>message</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#spack.tty.info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.msg">
<tt class="descclassname">spack.tty.</tt><tt class="descname">msg</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#spack.tty.msg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.pkg">
<tt class="descclassname">spack.tty.</tt><tt class="descname">pkg</tt><big>(</big><em>message</em><big>)</big><a class="headerlink" href="#spack.tty.pkg" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a message with a package icon.</p>
</dd></dl>

<dl class="function">
<dt id="spack.tty.verbose">
<tt class="descclassname">spack.tty.</tt><tt class="descname">verbose</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#spack.tty.verbose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.tty.warn">
<tt class="descclassname">spack.tty.</tt><tt class="descname">warn</tt><big>(</big><em>message</em>, <em>*args</em><big>)</big><a class="headerlink" href="#spack.tty.warn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-spack.url">
<span id="url-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">url</span></tt> Module<a class="headerlink" href="#module-spack.url" title="Permalink to this headline">¶</a></h2>
<p>This module has methods for parsing names and versions of packages from URLs.
The idea is to allow package creators to supply nothing more than the
download location of the package, and figure out version and name information
from there.</p>
<p>Example: when spack is given the following URL:</p>
<blockquote>
<div><a class="reference external" href="ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.1-p243.tar.gz">ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.9.1-p243.tar.gz</a></div></blockquote>
<p>It can figure out that the package name is ruby, and that it is at version
1.9.1-p243.  This is useful for making the creation of packages simple: a user
just supplies a URL and skeleton code is generated automatically.</p>
<p>Spack can also figure out that it can most likely download 1.8.1 at this URL:</p>
<blockquote>
<div><a class="reference external" href="ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.8.1.tar.gz">ftp://ftp.ruby-lang.org/pub/ruby/1.9/ruby-1.8.1.tar.gz</a></div></blockquote>
<p>This is useful if a user asks for a package at a particular version number;
spack doesn&#8217;t need anyone to tell it where to get the tarball even though
it&#8217;s never been told about that version before.</p>
<dl class="exception">
<dt id="spack.url.UndetectableNameError">
<em class="property">exception </em><tt class="descclassname">spack.url.</tt><tt class="descname">UndetectableNameError</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.UndetectableNameError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.url.UrlParseError" title="spack.url.UrlParseError"><tt class="xref py py-class docutils literal"><span class="pre">spack.url.UrlParseError</span></tt></a></p>
<p>Raised when we can&#8217;t parse a package name from a string.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.url.UndetectableVersionError">
<em class="property">exception </em><tt class="descclassname">spack.url.</tt><tt class="descname">UndetectableVersionError</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.UndetectableVersionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.url.UrlParseError" title="spack.url.UrlParseError"><tt class="xref py py-class docutils literal"><span class="pre">spack.url.UrlParseError</span></tt></a></p>
<p>Raised when we can&#8217;t parse a version from a string.</p>
</dd></dl>

<dl class="exception">
<dt id="spack.url.UrlParseError">
<em class="property">exception </em><tt class="descclassname">spack.url.</tt><tt class="descname">UrlParseError</tt><big>(</big><em>msg</em>, <em>path</em><big>)</big><a class="headerlink" href="#spack.url.UrlParseError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#spack.error.SpackError" title="spack.error.SpackError"><tt class="xref py py-class docutils literal"><span class="pre">spack.error.SpackError</span></tt></a></p>
<p>Raised when the URL module can&#8217;t parse something correctly.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.parse_name">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_name</tt><big>(</big><em>path</em>, <em>ver=None</em><big>)</big><a class="headerlink" href="#spack.url.parse_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.url.parse_name_and_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_name_and_version</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.parse_name_and_version" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="spack.url.parse_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_version</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.parse_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a URL or archive name, extract a version from it and return
a version object.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.parse_version_string_with_indices">
<tt class="descclassname">spack.url.</tt><tt class="descname">parse_version_string_with_indices</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.parse_version_string_with_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to extract a version string from a filename or URL.  This is taken
largely from Homebrew&#8217;s Version class.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.substitute_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">substitute_version</tt><big>(</big><em>path</em>, <em>new_version</em><big>)</big><a class="headerlink" href="#spack.url.substitute_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a URL or archive name, find the version in the path and substitute
the new version for it.</p>
</dd></dl>

<dl class="function">
<dt id="spack.url.wildcard_version">
<tt class="descclassname">spack.url.</tt><tt class="descname">wildcard_version</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#spack.url.wildcard_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the version in the supplied path, and return a regular expression
that will match this path with any version in its place.</p>
</dd></dl>

</div>
<div class="section" id="module-spack.validate">
<span id="validate-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">validate</span></tt> Module<a class="headerlink" href="#module-spack.validate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="spack.validate.url">
<tt class="descclassname">spack.validate.</tt><tt class="descname">url</tt><big>(</big><em>url_string</em><big>)</big><a class="headerlink" href="#spack.validate.url" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-spack.version">
<span id="version-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">version</span></tt> Module<a class="headerlink" href="#module-spack.version" title="Permalink to this headline">¶</a></h2>
<p>This module implements Version and version-ish objects.  These are:</p>
<dl class="docutils">
<dt>Version</dt>
<dd>A single version of a package.</dd>
<dt>VersionRange</dt>
<dd>A range of versions of a package.</dd>
<dt>VersionList</dt>
<dd>A list of Versions and VersionRanges.</dd>
</dl>
<p>All of these types support the following operations, which can
be called on any of the types:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__eq__</span><span class="p">,</span> <span class="n">__ne__</span><span class="p">,</span> <span class="n">__lt__</span><span class="p">,</span> <span class="n">__gt__</span><span class="p">,</span> <span class="n">__ge__</span><span class="p">,</span> <span class="n">__le__</span><span class="p">,</span> <span class="n">__hash__</span>
<span class="n">__contains__</span>
<span class="n">satisfies</span>
<span class="n">overlaps</span>
<span class="n">union</span>
<span class="n">intersection</span>
<span class="n">concrete</span>
</pre></div>
</div>
<dl class="class">
<dt id="spack.version.Version">
<em class="property">class </em><tt class="descclassname">spack.version.</tt><tt class="descname">Version</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.version.Version" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Class to represent versions</p>
<dl class="attribute">
<dt id="spack.version.Version.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.version.Version.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.Version.highest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.Version.lowest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.Version.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.Version.up_to">
<tt class="descname">up_to</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#spack.version.Version.up_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a version string up to the specified component, exclusive.
e.g., if this is 10.8.2, self.up_to(2) will return &#8216;10.8&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.Version.wildcard">
<tt class="descname">wildcard</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.Version.wildcard" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regex that will match variants of this version string.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.version.VersionList">
<em class="property">class </em><tt class="descclassname">spack.version.</tt><tt class="descname">VersionList</tt><big>(</big><em>vlist=None</em><big>)</big><a class="headerlink" href="#spack.version.VersionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Sorted, non-redundant list of Versions and VersionRanges.</p>
<dl class="method">
<dt id="spack.version.VersionList.add">
<tt class="descname">add</tt><big>(</big><em>version</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="spack.version.VersionList.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.version.VersionList.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionList.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionList.highest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the highest version in the list.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.intersect">
<tt class="descname">intersect</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.intersect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionList.lowest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the lowest version in the list.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.satisfies">
<tt class="descname">satisfies</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.satisfies" title="Permalink to this definition">¶</a></dt>
<dd><p>Synonym for overlaps.</p>
</dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionList.update">
<tt class="descname">update</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionList.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="spack.version.VersionRange">
<em class="property">class </em><tt class="descclassname">spack.version.</tt><tt class="descname">VersionRange</tt><big>(</big><em>start</em>, <em>end</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<dl class="attribute">
<dt id="spack.version.VersionRange.concrete">
<tt class="descname">concrete</tt><a class="headerlink" href="#spack.version.VersionRange.concrete" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.highest">
<tt class="descname">highest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionRange.highest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.intersection">
<tt class="descname">intersection</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.lowest">
<tt class="descname">lowest</tt><big>(</big><big>)</big><a class="headerlink" href="#spack.version.VersionRange.lowest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.overlaps">
<tt class="descname">overlaps</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.overlaps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="spack.version.VersionRange.union">
<tt class="descname">union</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.VersionRange.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="spack.version.coerce_versions">
<tt class="descclassname">spack.version.</tt><tt class="descname">coerce_versions</tt><big>(</big><em>a</em>, <em>b</em><big>)</big><a class="headerlink" href="#spack.version.coerce_versions" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert both a and b to the &#8216;greatest&#8217; type between them, in this order:
Version &lt; VersionRange &lt; VersionList
This is used to simplify comparison operations below so that we&#8217;re always
comparing things that are of the same type.</p>
</dd></dl>

<dl class="function">
<dt id="spack.version.coerced">
<tt class="descclassname">spack.version.</tt><tt class="descname">coerced</tt><big>(</big><em>method</em><big>)</big><a class="headerlink" href="#spack.version.coerced" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator that ensures that argument types of a method are coerced.</p>
</dd></dl>

<dl class="function">
<dt id="spack.version.int_if_int">
<tt class="descclassname">spack.version.</tt><tt class="descname">int_if_int</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#spack.version.int_if_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string to int if possible.  Otherwise, return a string.</p>
</dd></dl>

<dl class="function">
<dt id="spack.version.ver">
<tt class="descclassname">spack.version.</tt><tt class="descname">ver</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#spack.version.ver" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a Version, VersionRange, or VersionList from a string
or list of strings.</p>
</dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="spack.cmd.html">cmd Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#id1"><tt class="docutils literal"><span class="pre">cmd</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.arch"><tt class="docutils literal"><span class="pre">arch</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.bootstrap"><tt class="docutils literal"><span class="pre">bootstrap</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.checksum"><tt class="docutils literal"><span class="pre">checksum</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.clean"><tt class="docutils literal"><span class="pre">clean</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.compilers"><tt class="docutils literal"><span class="pre">compilers</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.create"><tt class="docutils literal"><span class="pre">create</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.doc"><tt class="docutils literal"><span class="pre">doc</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.edit"><tt class="docutils literal"><span class="pre">edit</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.fetch"><tt class="docutils literal"><span class="pre">fetch</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.find"><tt class="docutils literal"><span class="pre">find</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.graph"><tt class="docutils literal"><span class="pre">graph</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.help"><tt class="docutils literal"><span class="pre">help</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.info"><tt class="docutils literal"><span class="pre">info</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.install"><tt class="docutils literal"><span class="pre">install</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.list"><tt class="docutils literal"><span class="pre">list</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.providers"><tt class="docutils literal"><span class="pre">providers</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.purge"><tt class="docutils literal"><span class="pre">purge</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.python"><tt class="docutils literal"><span class="pre">python</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.spec"><tt class="docutils literal"><span class="pre">spec</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.stage"><tt class="docutils literal"><span class="pre">stage</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.test"><tt class="docutils literal"><span class="pre">test</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.uninstall"><tt class="docutils literal"><span class="pre">uninstall</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.cmd.html#module-spack.cmd.versions"><tt class="docutils literal"><span class="pre">versions</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.compilers.html">compilers Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#id1"><tt class="docutils literal"><span class="pre">compilers</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers.gcc"><tt class="docutils literal"><span class="pre">gcc</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.compilers.html#module-spack.compilers.intel"><tt class="docutils literal"><span class="pre">intel</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.packages.html">packages Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#id1"><tt class="docutils literal"><span class="pre">packages</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.callpath"><tt class="docutils literal"><span class="pre">callpath</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.cmake"><tt class="docutils literal"><span class="pre">cmake</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.dyninst"><tt class="docutils literal"><span class="pre">dyninst</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.libdwarf"><tt class="docutils literal"><span class="pre">libdwarf</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.libelf"><tt class="docutils literal"><span class="pre">libelf</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.libunwind"><tt class="docutils literal"><span class="pre">libunwind</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.mpich"><tt class="docutils literal"><span class="pre">mpich</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.packages.html#module-spack.packages.mpileaks"><tt class="docutils literal"><span class="pre">mpileaks</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.test.html">test Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#id1"><tt class="docutils literal"><span class="pre">test</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.concretize"><tt class="docutils literal"><span class="pre">concretize</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.mock_packages_test"><tt class="docutils literal"><span class="pre">mock_packages_test</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.multimethod"><tt class="docutils literal"><span class="pre">multimethod</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.spec_dag"><tt class="docutils literal"><span class="pre">spec_dag</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.spec_semantics"><tt class="docutils literal"><span class="pre">spec_semantics</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.spec_syntax"><tt class="docutils literal"><span class="pre">spec_syntax</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.stage"><tt class="docutils literal"><span class="pre">stage</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.url_parse"><tt class="docutils literal"><span class="pre">url_parse</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#module-spack.test.versions"><tt class="docutils literal"><span class="pre">versions</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.test.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="spack.test.mock_packages.html">mock_packages Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.callpath"><tt class="docutils literal"><span class="pre">callpath</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.dyninst"><tt class="docutils literal"><span class="pre">dyninst</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.fake"><tt class="docutils literal"><span class="pre">fake</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.libdwarf"><tt class="docutils literal"><span class="pre">libdwarf</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.libelf"><tt class="docutils literal"><span class="pre">libelf</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.mpich"><tt class="docutils literal"><span class="pre">mpich</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.mpich2"><tt class="docutils literal"><span class="pre">mpich2</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.mpileaks"><tt class="docutils literal"><span class="pre">mpileaks</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.multimethod"><tt class="docutils literal"><span class="pre">multimethod</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="spack.test.mock_packages.html#module-spack.test.mock_packages.zmpi"><tt class="docutils literal"><span class="pre">zmpi</span></tt> Module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="spack.util.html">util Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.compression"><tt class="docutils literal"><span class="pre">compression</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.crypto"><tt class="docutils literal"><span class="pre">crypto</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.environment"><tt class="docutils literal"><span class="pre">environment</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.executable"><tt class="docutils literal"><span class="pre">executable</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.filesystem"><tt class="docutils literal"><span class="pre">filesystem</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.lang"><tt class="docutils literal"><span class="pre">lang</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.none_high"><tt class="docutils literal"><span class="pre">none_high</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.none_low"><tt class="docutils literal"><span class="pre">none_low</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.prefix"><tt class="docutils literal"><span class="pre">prefix</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.string"><tt class="docutils literal"><span class="pre">string</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="spack.util.html#module-spack.util.web"><tt class="docutils literal"><span class="pre">web</span></tt> Module</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          <footer>
  
    <div class="rst-footer-buttons">
      
        <a href="spack.cmd.html" class="btn btn-neutral float-right" title="cmd Package"/>Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="developer_guide.html" class="btn btn-neutral" title="Developer Guide"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <p>
    &copy; Copyright 2013,
    <a href="https://scalability.llnl.gov/">Lawrence Livermore National Laboratory</a>.
    <br/>
    Written by Todd Gamblin, <a href="mailto:tgamblin@llnl.gov">tgamblin@llnl.gov</a>, LLNL-CODE-647188
    <br/>
    Last updated on Jan 15, 2014.
  &nbsp;&nbsp;
  <br/><a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
  </p>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>